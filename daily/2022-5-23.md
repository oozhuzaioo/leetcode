## 每日一题 - 数组中重复的数字

### 信息卡片 

- 时间： 2022-05-23
- 题目链接：https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
- tag：算法，哈希

- 题目描述：
```
找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
 

限制：

2 <= n <= 100000

```

### 参考答案

#### 暴力遍历法
题目的要求是找到重复的数字，那么如果我们用暴力遍历的方法，第一个数字和后面的比较，如果没有重复i++，然后继续，这种方法需要时间复杂度是o(n^2)，空间复杂度是o(1)。

#### 空间换时间法
思路一不好的地方就在于，时间复杂度太高了，我们一般这种降低时间复杂度的方法就是，通过空间换时间，就是例如哈希表或者集合，把遍历过的值记录下来，这样就可以节约大量的时间，所以方法二就是使用哈希表把遍历过的元素存下来，如果发现一次就记录1，发现两次就记录2，并且每次遍历检查，如果大于等于2了，就返回该重复的数字，这种方法很好理解，也是大多数人会使用的方法，这种方法的好处在于把时间复杂度降低到了o(n)，但同样付出的代价是空间复杂度上升到了o(n)。

```C++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        //哈希表解法  
        unordered_map<int,int> mp;
        for(auto& num:nums)
        {
            mp[num]++;
            if(mp[num]>1)
                return num;
        }
        return 0;
    }
};

```

#### 原地交换
进一步考虑，有n个数，其中有部分是重复的，那么只要使索引与索引对应的值相等即可。
通过不断将索引值放到适当的索引位置上，当出现索引位有对应值的时候，即表示这个值位为重复数

```C++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for(int i=0;i<nums.size();) {
            if(nums[i] == i) {
                i++;
                continue;
            } else if (nums[i] == nums[nums[i]]) {
                return nums[i];
            }
            else {
                swap(nums[nums[i]], nums[i]);
            }
        }
        return 0;
    }
};
```
### 扩展
 -  在unordered_map中，[]也可以直接获取key对应的值。不过需要注意的是，如果key不在map中，[]这种方式会将key插入map中
 - 第三种方法要注意i++的位置，只有相等的时候，才往后找一个，否则原地继续判断看交换后的值。
### 我的思考
- **注意看已知条件**：已知条件说明，数据范围在0~n-1之间，所以可以有第三种解法。
- **套娃的思想**：i先和nums[i]比较，确认本地是不是出现过了，如果没有出现过，去找第nums[i]个值（因为我们的目的是让i和nums[i]一一对应，如果已经对应上了，说明这个值就是哈希冲突）如果都不满足，就交换位置，让他回到应该到的地方。

